//假设Q[1…10]是一个顺序队列，初始状态为front=rear=0，A…Z入队，并求出元素个数。
#include <stdio.h>
#include <malloc.h>
#define MAXLEN 100
#define ElemType char

typedef struct
{
    ElemType data[MAXLEN];
    int front;
    int rear;
    int flag;   //每进行一次出队运算时，标示量flag设为0
}SeqQueue;

//循环队列置空
SeqQueue * initQueue(SeqQueue * q)
{
    q->front = 0;
    q->rear = 0;
    return q;
}

//建一个空循环队列
SeqQueue * setQueue()
{
    SeqQueue * Q = (SeqQueue *)malloc(sizeof(SeqQueue));
    Q->front = 0;
    Q->rear = 0;
    Q->flag = 0;
    return Q;
}

//判队满
int QueueFull(SeqQueue * q)
{
    if ((q->front == (q->rear)%MAXLEN) && q->flag ==1)
        return 1;
    else
        return 0;
}

//判队空
int QueueEmpty(SeqQueue *q)
{
    if ((q->front == (q->rear)%MAXLEN) && q->flag == 0)
        return 1;
    else
        return 0;
}

//入队
void push(SeqQueue * q, ElemType ch)
{
    if (QueueFull(q))
        printf("queue full");
    else
    {
        q->flag = 1;
        q->data[q->rear % MAXLEN] = ch;
        q->rear = (q->rear + 1) % MAXLEN;
    }
}

//出队
void pop(SeqQueue * q)
{
    if (QueueEmpty(q))
        printf("queue empty");
    else
    {
        q->front = (q->front + 1) % MAXLEN;
        q->flag = 0;
    }
}

int getQueueNum(SeqQueue * q)
{
    int num = q->rear - q->front;
    return num;
}

//输出队中有效元素
void showQueue(SeqQueue * q)
{
    int i;
    for (i = q->front; i < q->rear; ++i)
        printf("%c ", q->data[i]);
    printf("\n");
}

int main(void)
{
    SeqQueue * Q = setQueue();

    int i = 0;
    ElemType ch = 'A';
    for (i = 0; i < 26; ++i)    //队里放26个字母
    {
        push(Q, ch++);
    }

  //pop(Q);
  //printf("%s\n", Q->data);
    showQueue(Q);
    printf("%d\n", getQueueNum(Q));

    return 0;
}
